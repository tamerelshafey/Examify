import { GoogleGenAI, Type } from "@google/genai";
import { Exam, ExamResult, Question, QuestionType, Answer, ProctoringEvent, LearningPath, MarketplaceQuestionBank, OralExamAnalysis, TranscriptItem, AIRecommendedBank, StudentRiskProfile, QuestionStatus } from "../types";

// NOTE: This is a mock AI service. In a real application, these functions would
// make calls to the Gemini API with appropriate prompts and configurations.
// The API key is mocked here for demonstration purposes.
const ai = new GoogleGenAI({ apiKey: process.env.REACT_APP_API_KEY || "mock_api_key" });

export const getAIQuestionSuggestions = async (params: { partialQuestionText: string }): Promise<Omit<Question, 'id' | 'ownerId' | 'category' | 'subCategory' | 'status'>> => {
    await new Promise(resolve => setTimeout(resolve, 800));
    return {
        text: `${params.partialQuestionText} (completed by AI)`,
        type: QuestionType.MultipleChoice,
        options: ['AI Option 1', 'AI Option 2', 'AI Correct Answer'],
        correctAnswer: 'AI Correct Answer',
        points: 5,
        tags: ['ai-generated'],
    };
};

export type AnalysisResult = { feedback: string; category: string; subCategory: string; tags: string[] };

export const analyzeQuestionWithAI = async (params: { questionText: string; existingCategories: Record<string, string[]> }): Promise<AnalysisResult> => {
    await new Promise(resolve => setTimeout(resolve, 1000));
    const categories = Object.keys(params.existingCategories);
    const category = categories[Math.floor(Math.random() * categories.length)] || "General";
    const subCategories = params.existingCategories[category] || [];
    const subCategory = subCategories[Math.floor(Math.random() * subCategories.length)] || "Basics";
    
    return {
        feedback: "This is a well-structured question that effectively tests the core concept. Consider adding a code snippet for context.",
        category: category,
        subCategory: subCategory,
        tags: ["core-concept", "ai-suggested"],
    };
};

export const generateQuestionsWithAI = async (params: { topic: string, questionType: QuestionType, difficulty: 'Easy' | 'Medium' | 'Hard', count: number }): Promise<Omit<Question, 'id'>[]> => {
    await new Promise(resolve => setTimeout(resolve, 1500));
    return Array.from({ length: params.count }, (_, i) => ({
        text: `AI-generated question about ${params.topic} #${i + 1}?`,
        type: params.questionType,
        options: ['Option A', 'Option B', 'Option C', 'Option D'],
        correctAnswer: 'Option C',
        points: 5,
        tags: [params.topic.toLowerCase(), 'ai-generated'],
        ownerId: '', // To be filled by caller
        category: '', // To be filled by caller
        subCategory: '', // To be filled by caller
        status: QuestionStatus.Approved,
    }));
};

export const generateFullExamWithAI = async (params: { topic: string; difficulty: 'Easy' | 'Medium' | 'Hard'; count: number }): Promise<Omit<Exam, 'id' | 'questionCount'>> => {
    await new Promise(resolve => setTimeout(resolve, 2500));
    const questions = await generateQuestionsWithAI({ ...params, questionType: QuestionType.MultipleChoice });
    return {
        title: `AI-Generated Exam: ${params.topic}`,
        description: `An exam about ${params.topic} generated by AI.`,
        duration: params.count * 2,
        difficulty: params.difficulty,
        questions: questions as Question[],
    };
};

export const getAIExplanation = async (params: { questionText: string; studentAnswer: string; correctAnswer: string; }): Promise<{ explanation: string }> => {
    await new Promise(resolve => setTimeout(resolve, 1200));
    return {
        explanation: `Your answer, "${params.studentAnswer}", was incorrect because it missed the key point about the correct answer, which is "${params.correctAnswer}". The AI suggests reviewing the topic related to "${params.questionText}".`,
    };
};

export const generateAICertificateCommendation = async (params: {
    examineeName: string;
    examTitle: string;
    scorePercentage: number;
}): Promise<{ commendation: string }> => {
    await new Promise(resolve => setTimeout(resolve, 1200));

    let praise = "excellent performance";
    if (params.scorePercentage > 95) {
        praise = "outstanding achievement";
    } else if (params.scorePercentage > 85) {
        praise = "a strong grasp of the subject";
    }

    const commendation = `For demonstrating ${praise} in "${params.examTitle}" and achieving a remarkable score of ${params.scorePercentage}%.`;
    
    return { commendation };
};

export const generatePersonalizedLearningPath = async (params: { exam: Exam; result: ExamResult }): Promise<LearningPath> => {
    await new Promise(resolve => setTimeout(resolve, 2000));
    return {
        examineeName: params.result.examineeName,
        examTitle: params.exam.title,
        identifiedWeaknesses: [
            'Understanding of React Hooks',
            'State management concepts'
        ],
        learningPlan: [
            {
                concept: 'React `useEffect` Hook',
                explanation: 'A key area for improvement is understanding the dependency array in the `useEffect` hook.',
                suggestedResources: [{ title: 'Official React Docs on Hooks', uri: 'https://reactjs.org/docs/hooks-effect.html' }],
                practiceQuestions: [{ text: 'What is the purpose of the `useEffect` cleanup function?', answer: 'To clean up resources like subscriptions or timers before the component unmounts.' }],
            }
        ]
    };
};

export const gradeAnswerWithAI = async (params: { questionText: string; studentAnswer: string; modelAnswer: string; points: number; }): Promise<{ suggestedScore: number; feedback: string; }> => {
    await new Promise(resolve => setTimeout(resolve, 1500));
    const score = Math.floor(Math.random() * params.points);
    return {
        suggestedScore: score,
        feedback: `The answer is partially correct but lacks detail. It could be improved by mentioning... (AI feedback).`,
    };
};

export const checkPlagiarismWithAI = async (params: { studentAnswer: string }): Promise<{ similarityScore: number; justification: string; sources: any[]; }> => {
    await new Promise(resolve => setTimeout(resolve, 1800));
    return {
        similarityScore: Math.floor(Math.random() * 40), // Low similarity for mock
        justification: "The text appears to be original with no significant matches found on public sources.",
        sources: [],
    };
};

export const checkAuthenticityWithAI = async (params: { studentAnswer: string }): Promise<{ authenticityScore: number; justification: string; }> => {
    await new Promise(resolve => setTimeout(resolve, 1800));
    return {
        authenticityScore: Math.floor(Math.random() * (100 - 80) + 80), // High authenticity for mock
        justification: "The writing style, complexity, and vocabulary are consistent with human-written text for this educational level.",
    };
};

export interface AIScreeningResult {
    qualityScore: number;
    relevanceScore: number;
    recommendation: 'Strongly Consider' | 'Review with Caution' | 'Likely Reject';
    justification: string;
}
export const preScreenSubmittedBankWithAI = async (bank: MarketplaceQuestionBank): Promise<AIScreeningResult> => {
    await new Promise(resolve => setTimeout(resolve, 2000));
    return {
        qualityScore: Math.floor(Math.random() * (95 - 75) + 75),
        relevanceScore: Math.floor(Math.random() * (98 - 80) + 80),
        recommendation: 'Strongly Consider',
        justification: 'The questions are well-formed, cover the topic comprehensively, and are of appropriate difficulty for the specified category.',
    };
};

export const findMarketplaceBanksWithAI = async (query: string): Promise<AIRecommendedBank[]> => {
    await new Promise(resolve => setTimeout(resolve, 1500));
    // Simulate finding the top 2 banks
    return [
        { bankId: 'mkb-1', justification: `Excellent match for foundational concepts mentioned in your query.` },
        { bankId: 'mkb-3', justification: `Relevant due to its focus on modern web development techniques.` },
    ];
};

export const analyzeProctoringSessionWithAI = async (params: { examineeName: string; examTitle: string; examDuration: number; proctoringEvents: ProctoringEvent[] }): Promise<{ integrityScore: number; analyticalSummary: string; events: any[] }> => {
    await new Promise(resolve => setTimeout(resolve, 2000));
    const score = 100 - params.proctoringEvents.length * 15;
    return {
        integrityScore: Math.max(0, score),
        analyticalSummary: `The session for ${params.examineeName} showed ${params.proctoringEvents.length} potential integrity issues. The main concern was multiple tab switches, indicating external resource usage.`,
        events: params.proctoringEvents.map(e => ({...e, timestamp: new Date(e.timestamp).toISOString().substr(11, 8)})),
    };
};

export const parseExamTextWithAI = async(params: { rawText: string }): Promise<Omit<Question, 'id' | 'ownerId' | 'category' | 'subCategory' | 'status'>[]> => {
    await new Promise(resolve => setTimeout(resolve, 2000));
    return [
        { text: "Parsed Question 1 from text?", type: QuestionType.MultipleChoice, options: ["Option A", "Option B"], correctAnswer: "Option A", points: 5, tags: ["parsed"] },
        { text: "Parsed Question 2: True or False?", type: QuestionType.TrueFalse, correctAnswer: "True", points: 10, tags: ["parsed"] },
    ];
}

export const predictStudentPerformance = async (results: ExamResult[]): Promise<StudentRiskProfile[]> => {
    await new Promise(resolve => setTimeout(resolve, 800));
    if (results.length > 0) {
        return [{
            studentId: 'user-2',
            studentName: 'Fatima Ahmed',
            riskLevel: 'medium',
            averageScore: 75,
            recentScores: [80, 70],
            prediction: 'Student shows a slight downward trend. Recommend monitoring.'
        }];
    }
    return [];
};


export const getInitialAiTutorMessage = async (results: ExamResult[], exams: Omit<Exam, 'questions'>[]): Promise<{ message: string }> => {
    await new Promise(resolve => setTimeout(resolve, 500));
    return { message: "Hello! I'm your AI Study Buddy. How can I help you prepare today? You can ask me for a practice question on a specific topic." };
};

export const generateSingleQuestionWithAI = async (params: { topic: string; difficulty: 'Easy' | 'Medium' | 'Hard'; questionType: QuestionType }): Promise<Question> => {
    await new Promise(resolve => setTimeout(resolve, 1200));
    return {
        id: `ai-q-${Date.now()}`,
        ownerId: 'ai-tutor',
        text: `Here is a new ${params.difficulty} ${params.questionType} question about ${params.topic}:`,
        type: params.questionType,
        points: 5,
        category: 'AI Tutor',
        subCategory: params.topic,
        correctAnswer: 'The correct AI answer',
        options: ['AI Option 1', 'The correct AI answer', 'AI Option 3'],
        status: QuestionStatus.Approved,
    };
};

export const analyzeOralExamPerformance = async (params: { transcript: TranscriptItem[], topic: string }): Promise<OralExamAnalysis> => {
    await new Promise(resolve => setTimeout(resolve, 2500));
    return {
        fluency: { score: 85, feedback: "Good flow of speech with minimal hesitation. Some sentences could be more complex." },
        pronunciation: { score: 92, feedback: "Clear and easily understandable pronunciation throughout the session." },
        grammar: { score: 78, feedback: "Generally good grammar, but a few minor errors in verb tense were noted." },
        overallFeedback: `Great job discussing ${params.topic}! You communicated your ideas clearly. To improve, focus on expanding your vocabulary and using more varied sentence structures. Keep practicing!`,
    };
};

export const analyzeExamResultsWithAI = async (params: { examTitle: string, keyMetrics: any, questionPerformance: any[] }): Promise<{ analysis: string }> => {
    await new Promise(resolve => setTimeout(resolve, 2000));

    const hardestQuestion = params.questionPerformance.reduce((min, q) => q.correctPercentage < min.correctPercentage ? q : min, params.questionPerformance[0] || { text: 'N/A' });
    const easiestQuestion = params.questionPerformance.reduce((max, q) => q.correctPercentage > max.correctPercentage ? q : max, params.questionPerformance[0] || { text: 'N/A' });

    const analysis = `
**Overall Performance:** The average score for "${params.examTitle}" was ${params.keyMetrics.averageScore}%, with a pass rate of ${params.keyMetrics.passRate}%. This indicates a solid understanding of the material overall.

**Key Observation:** There appears to be a significant performance gap on question "${hardestQuestion.text.substring(0, 50)}..." (${hardestQuestion.correctPercentage}% correct). This suggests the underlying concept may require further review.

**Recommendation:** Consider a follow-up session focusing on the topic of the most difficult question. In contrast, students excelled at "${easiestQuestion.text.substring(0, 50)}...", indicating strong mastery of that area.
    `.trim();

    return { analysis };
};